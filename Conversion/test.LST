C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TEST
OBJECT MODULE PLACED IN test.OBJ
COMPILER INVOKED BY: G:\Keil\C51\BIN\C51.EXE test.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <stdlib.h>
   4          #define uint unsigned int
   5          #define uchar unsigned char
   6          
   7          /*---------宏定义---------*/
   8          #define cstAdcPower 0X80   /*ADC电源开关*/
   9          #define cstAdcFlag 0X10    /*当A/D转换完成后，cstAdcFlag要软件清零*/
  10          #define cstAdcStart 0X08   /*当A/D转换完成后，cstAdcStart会自动清零，所以要开始下一次转换，则需要置位*/
  11          #define cstAdcSpeed90 0X60 /*ADC转换速度 90个时钟周期转换一次*/
  12          #define cstAdcChs17 0X07   /*选择P1.7作为A/D输入*/
  13          
  14          uchar arrSegSelect[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x00, 0x38, 0x74, 0x67, 0xa7};
  15          uchar arrDigitSelect[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; //数码管0-7
  16          uchar arrLEDselect[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};   //LED灯
  17          uint arrPrintSelect[]={16,16,16,16,16,16,16,16};
  18          uchar arrListSelect[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  19          /*---------引脚别名定义---------*/
  20          sbit sbtLedSel = P2 ^ 3; //数码管与LED灯切换引脚
  21          sbit sbtVib = P2 ^ 4;     //振动传感器
  22          
  23          /*---------变量定义---------*/
  24          uchar uiLed = 0x00;      //LED灯值寄存
  25          uchar tmpLed = 0x01; //LED灯值暂存
  26          uchar i = 0;             //数码管扫描显示循环
  27          uint answer = 0;         //答案
  28          uint score = 0;          //得分
  29          uint highest_sc = 0; //最高分
  30          uint highest_er=0;       //最高分玩家
  31          uint player=0;           //当前游戏玩家
  32          uint ques = 0;           //问题
  33          uint ques0, ques1, ques2;
  34          uint ques_flag = 0; //问题标志
  35          uchar option=0x00;              //选项
  36          uint back=0;
  37          
  38          /*---------引脚别名定义---------*/
  39          sbit sbtBeep = P3 ^ 4; //蜂鸣器引脚
  40          sbit sbtKey1 = P3 ^ 2; //按键1引脚
  41          sbit sbtKey2 = P3 ^ 3;
  42          sbit sbtKey3 = P1 ^ 7;
  43          /*---------变量定义---------*/
  44          bit btBeepFlag; //控制蜂鸣器开关的标志位
  45           
  46          
  47          /*---------初始化函数--------*/
  48          void Init()
  49          {
  50   1              P0M1 = 0x00;
  51   1              P0M0 = 0xff;
  52   1              P2M1 = 0x00;
  53   1              P2M0 = 0x08;
  54   1              P3M1 = 0x00;
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 2   

  55   1              P3M0 = 0x10; //设置P3^4为推挽模式
  56   1              
  57   1          sbtLedSel = 0;      //选择数码管作为输出
  58   1          P1ASF = 0x80;       //P1.7作为模拟功能A/D使用
  59   1          ADC_RES = 0;        //转换结果清零
  60   1          ADC_CONTR = 0x8F;   //cstAdcPower = 1
  61   1          CLK_DIV = 0X00;     //ADRJ = 0    ADC_RES存放高八位结果
  62   1          IT0 = 0;            //设置IT0上升沿触发
  63   1          IT1 = 0;
  64   1          EA = 1;             //CPU开放中断
  65   1              TMOD = 0x00; //设置定时器0，工作方式0，16位自动重装定时器
  66   1              TH0 = 0xff;      //设定定时器0的初值
  67   1              TL0 = 0x03;
  68   1              ET0 = 1; //打开定时器0中断允许位
  69   1              TR0 = 1;
  70   1              btBeepFlag = 0; //标志位置1
  71   1              P0 = 0x00;              //关闭P0端口
  72   1              sbtBeep = 0;    //蜂鸣器引脚置0，以保护蜂鸣器
  73   1              ques_flag = 0;
  74   1              sbtLedSel = 0; //先选择数码管亮
  75   1              uiLed = 0x00;
  76   1              sbtVib=1;
  77   1      }
  78          /*---------延时子函数--------*/
  79          void delay(uint n)
  80          {
  81   1              while (n--)
  82   1                      ;
  83   1      }
  84          void delay_ms( uint n )
  85          {
  86   1          while( n )
  87   1          {
  88   2              uchar i, j;
  89   2              i = 11;
  90   2              j = 190;
  91   2              do
  92   2              {
  93   3                  while ( --j );
  94   3              }
  95   2              while ( --i );
  96   2              n--;
  97   2          }
  98   1      }
  99          int game_back();
 100          void upload()
 101          {
 102   1              uiLed = 0x00;
 103   1              tmpLed = 0x01;
 104   1              ques_flag = 0;
 105   1              answer = P0;
 106   1              if (answer == ques)
 107   1              {
 108   2                      score++;
 109   2                      if (score == 15)
 110   2                      {
 111   3                              highest_sc = score;
 112   3                              highest_er = player;
 113   3                              arrListSelect[player]=score;
 114   3                              score=0;
 115   3                      }
 116   2              }
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 3   

 117   1              else
 118   1              {
 119   2                      if (score > highest_sc)
 120   2                      {
 121   3                              highest_sc = score;
 122   3                              highest_er = player;
 123   3                      }
 124   2                      /*btBeepFlag = ~btBeepFlag;
 125   2                      delay(600);
 126   2                      btBeepFlag = ~btBeepFlag;*/
 127   2                      arrListSelect[player]=score;
 128   2                      score = 0;
 129   2              }
 130   1      }
 131          
 132          /*---------获取AD值子函数--------*/
 133          unsigned char GetADC()
 134          {
 135   1          uchar ucAdcRes;
 136   1          ADC_CONTR = cstAdcPower | cstAdcStart | cstAdcSpeed90 | cstAdcChs17;//没有将cstAdcFlag置1，用于判断A/D
             -是否结束
 137   1          _nop_();
 138   1          _nop_();
 139   1          _nop_();
 140   1          _nop_();
 141   1          while( !( ADC_CONTR & cstAdcFlag ) ); //等待直到A/D转换结束
 142   1          ADC_CONTR &= ~cstAdcFlag;           //cstAdcFlagE软件清0
 143   1          ucAdcRes = ADC_RES;                 //获取AD的值
 144   1          return ucAdcRes;
 145   1      }
 146          
 147          /*---------获取导航按键值子函数--------*/
 148          uchar NavKeyCheck()
 149          {
 150   1              unsigned char key;
 151   1              key = GetADC(); //获取AD的值
 152   1              if (key != 255) //有按键按下时
 153   1              {
 154   2                      delay(200);
 155   2                      key = GetADC();
 156   2                      if (key != 255) //按键消抖 仍有按键按下
 157   2                      {
 158   3                              key = key & 0xE0;         //获取高3位，其他位清零
 159   3                              key = _cror_(key, 5); //循环右移5位 获取A/D转换高三位值，减小误差
 160   3                              return key;
 161   3                      }
 162   2              }
 163   1              return 0x07; //没有按键按下时返回值0x07
 164   1      }
 165          
 166          /*---------导航按键处理子函数--------*/
 167          void NavKey_Process()
 168          {
 169   1              uchar ucNavKeyCurrent; //导航按键当前的状态
 170   1              uchar ucNavKeyPast;        //导航按键前一个状态
 171   1      
 172   1              ucNavKeyCurrent = NavKeyCheck(); //获取当前ADC值
 173   1              if (ucNavKeyCurrent != 0x07)     //导航按键是否被按下 不等于0x07表示有按下
 174   1              {
 175   2                      ucNavKeyPast = ucNavKeyCurrent;
 176   2                      while (ucNavKeyCurrent != 0x07) //等待导航按键松开
 177   2                              ucNavKeyCurrent = NavKeyCheck();
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 4   

 178   2      
 179   2              switch( ucNavKeyPast )
 180   2              {
 181   3                  case 0x00 :                     //里
 182   3                              if (tmpLed == 0x00)
 183   3                                              tmpLed = 0x01;
 184   3                                      else
 185   3                                              tmpLed = tmpLed & 0x00;
 186   3                      break;
 187   3                  case 0x01 :                     //上键：显示的数字加1
 188   3                      if (tmpLed == 0x01) //value等于0x80时，重新赋初值0x01
 189   3                                      tmpLed = 0x80;
 190   3                                      else
 191   3                                      tmpLed = tmpLed >> 1;
 192   3                      break;
 193   3                  case 0x04 :                     //下键：显示的数字减1
 194   3                      if (tmpLed == 0x80) //value等于0x80时，重新赋初值0x01
 195   3                                              tmpLed = 0x01;
 196   3                                      else
 197   3                                              tmpLed = tmpLed << 1;
 198   3                      break;
 199   3                              case 0x02:
 200   3                                      back=game_back();
 201   3                                      break;
 202   3              }
 203   2          }
 204   1      
 205   1          delay(1000);
 206   1      }
 207          
 208          void question()
 209          {
 210   1              ques = rand() % 256;
 211   1              ques0 = ques % 10;
 212   1              ques1 = ques / 10 % 10;
 213   1              ques2 = ques / 100 % 10;
 214   1      }
 215          
 216          void clear()
 217          {
 218   1              for(i=0;i<8;i++)
 219   1                      arrPrintSelect[i]=16;
 220   1      }
 221          
 222          void print()
 223          {
 224   1              for( i = 0; i < 8; i++ )
 225   1              {
 226   2                  P0 = 0;
 227   2                  P2 = arrDigitSelect[i];     //选择数码管的位数
 228   2                  P0 = arrSegSelect[arrPrintSelect[i]];  //显示对应的数值
 229   2                  delay_ms( 1 );
 230   2              }
 231   1      }
 232          
 233          void print_game()
 234          {
 235   1              clear();
 236   1              arrPrintSelect[0]=highest_sc;
 237   1              arrPrintSelect[3]=score;
 238   1              arrPrintSelect[5]=ques2;
 239   1              arrPrintSelect[6]=ques1;
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 5   

 240   1              arrPrintSelect[7]=ques0;
 241   1      }
 242          
 243          void print_manu()
 244          {
 245   1              clear();
 246   1              if(option==0x00)//GO
 247   1              {
 248   2                      arrPrintSelect[0]=0;
 249   2                      arrPrintSelect[4]=9;
 250   2                      arrPrintSelect[5]=0;
 251   2              }
 252   1              else
 253   1              {
 254   2                      arrPrintSelect[0]=1;
 255   2                      arrPrintSelect[4]=17;
 256   2                      arrPrintSelect[5]=1;
 257   2                      arrPrintSelect[6]=5;
 258   2                      arrPrintSelect[7]=7;
 259   2              }
 260   1      }
 261          
 262          void print_list()
 263          {
 264   1              clear();
 265   1              if(option==0x00)//high
 266   1              {
 267   2                      arrPrintSelect[0]=18;
 268   2                      arrPrintSelect[1]=1;
 269   2                      arrPrintSelect[2]=9;
 270   2                      arrPrintSelect[3]=18;
 271   2                      arrPrintSelect[5]=highest_er;
 272   2                      arrPrintSelect[7]=highest_sc;
 273   2              }
 274   1              else
 275   1              {
 276   2                      arrPrintSelect[0]=17;
 277   2                      arrPrintSelect[1]=1;
 278   2                      arrPrintSelect[2]=5;
 279   2                      arrPrintSelect[3]=7;
 280   2                      arrPrintSelect[5]=option-1;
 281   2                      arrPrintSelect[7]=arrListSelect[option-1];
 282   2              }
 283   1      }
 284          
 285          void print_login()
 286          {
 287   1              clear();
 288   1              arrPrintSelect[2]=1;
 289   1              arrPrintSelect[3]=13;
 290   1              arrPrintSelect[7]=player;
 291   1      }
 292          
 293          void print_back()
 294          {
 295   1              clear();
 296   1              arrPrintSelect[6]=19;
 297   1              arrPrintSelect[7]=20;
 298   1      }
 299          
 300          int game_back()
 301          {
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 6   

 302   1              while( 1 )
 303   1          {
 304   2                      sbtLedSel = 0;
 305   2                      print_back();
 306   2                      print();
 307   2              if (sbtKey1 == 0)
 308   2                      {
 309   3                              delay_ms(5); //延时消抖
 310   3                              if (sbtKey1 == 0)
 311   3                              {
 312   4                                      while( !sbtKey1 );
 313   4                                      {
 314   5                                              return 1;
 315   5                                      }
 316   4                              }
 317   3                      }
 318   2                      if (sbtKey2 == 0)
 319   2                      {
 320   3                              delay_ms(5); //延时消抖
 321   3                              if (sbtKey2 == 0)
 322   3                              {
 323   4                                      while( !sbtKey2 );
 324   4                                      {
 325   5                                              return 0;
 326   5                                      }
 327   4                              }
 328   3                      }
 329   2          }
 330   1      }
 331          
 332          void game()
 333          {
 334   1              clear();
 335   1              while( 1 )
 336   1          {
 337   2                      loop1:
 338   2                      sbtLedSel = 0;
 339   2                      if (ques_flag == 0)
 340   2                      {
 341   3                              question();
 342   3                              ques_flag = 1;
 343   3                      }
 344   2                      print_game();
 345   2                      print();
 346   2                      sbtLedSel = 1;
 347   2                      P0 = 0;
 348   2                      P0 = uiLed | tmpLed; //LED显示
 349   2                      delay_ms(1);    
 350   2                      NavKey_Process();         //获取按键按下情况
 351   2              if (sbtKey1 == 0)
 352   2                      {
 353   3                              delay_ms(5); //延时消抖
 354   3                              if (sbtKey1 == 0)
 355   3                              {
 356   4                                      while( !sbtKey1 );
 357   4                                      upload();
 358   4                                      goto loop1;
 359   4                              }
 360   3                      }
 361   2                      if (sbtKey2 == 0)
 362   2                      {
 363   3                              delay_ms(5); //延时消抖
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 7   

 364   3                              if (sbtKey2 == 0)
 365   3                              {
 366   4                                      while( !sbtKey2 );
 367   4                      uiLed = uiLed ^ tmpLed;
 368   4                              }
 369   3                      }
 370   2                      if(back==1)
 371   2                              return;
 372   2                      
 373   2                      //后加退出方法
 374   2          }
 375   1      }
 376          
 377          /*---------注册--------*/
 378          void login()
 379          {
 380   1              option=0x00;
 381   1              back=0;
 382   1              while( 1 )
 383   1          {
 384   2                      sbtLedSel = 0;
 385   2                      print_login();
 386   2                      print();
 387   2              if (sbtKey1 == 0)
 388   2                      {
 389   3                              delay_ms(5); //延时消抖
 390   3                              if (sbtKey1 == 0)
 391   3                              {
 392   4                                      while( !sbtKey1 );
 393   4                                      {
 394   5                                              game();
 395   5                                              return;
 396   5                                      }
 397   4                              }
 398   3                      }
 399   2                      if (sbtKey2 == 0)
 400   2                      {
 401   3                              delay_ms(5); //延时消抖
 402   3                              if (sbtKey2 == 0)
 403   3                              {
 404   4                                      while( !sbtKey2 );
 405   4                                      if(player==15)
 406   4                                              player=0;
 407   4                                      else
 408   4                                              player++;
 409   4                      //next
 410   4                              }
 411   3                      }
 412   2          }
 413   1              
 414   1      }
 415          
 416          /*---------排行--------*/
 417          void list()
 418          {
 419   1              option=0x00;
 420   1              while( 1 )
 421   1          {
 422   2                      sbtLedSel = 0;
 423   2                      print_list();
 424   2                      print();
 425   2              if (sbtKey1 == 0)
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 8   

 426   2                      {
 427   3                              delay_ms(5); //延时消抖
 428   3                              if (sbtKey1 == 0)
 429   3                              {
 430   4                                      while( !sbtKey1 );
 431   4                                      {
 432   5                                              option=0x00;
 433   5                                              break;
 434   5                                      }
 435   4                              }
 436   3                      }
 437   2                      if (sbtKey2 == 0)
 438   2                      {
 439   3                              delay_ms(5); //延时消抖
 440   3                              if (sbtKey2 == 0)
 441   3                              {
 442   4                                      while( !sbtKey2 );
 443   4                                      if(option==0x10)
 444   4                                              option=0x00;
 445   4                                      else
 446   4                                              option++;
 447   4                      //next
 448   4                              }
 449   3                      }
 450   2          }
 451   1      }
 452          
 453          /*---------主函数--------*/
 454          void main()
 455          {
 456   1          Init();
 457   1          while( 1 )
 458   1          {
 459   2                      sbtLedSel = 0;
 460   2                      print_manu();
 461   2                      print();
 462   2              if (sbtKey1 == 0)
 463   2                      {
 464   3                              delay_ms(5); //延时消抖
 465   3                              if (sbtKey1 == 0)
 466   3                              {
 467   4                                      while( !sbtKey1 );
 468   4                                      if(option==0x00)
 469   4                                              login();//注册并开始游戏
 470   4                                      else
 471   4                                              list();//查看排行
 472   4                              }
 473   3                      }
 474   2                      if (sbtKey2 == 0)
 475   2                      {
 476   3                              delay_ms(5); //延时消抖
 477   3                              if (sbtKey2 == 0)
 478   3                              {
 479   4                                      while( !sbtKey2 );
 480   4                      option=option^0x01;
 481   4                              }
 482   3                      }
 483   2          }
 484   1      }
 485          
 486          /*---------T0定时器中断服务处理函数--------*/
 487          void T0_Process() interrupt 1
C51 COMPILER V9.51   TEST                                                                  09/11/2020 19:14:20 PAGE 9   

 488          {
 489   1              if (btBeepFlag)
 490   1              {
 491   2                      sbtBeep = ~sbtBeep; //产生方波使得蜂鸣器发声
 492   2              }
 493   1              else
 494   1              {
 495   2                      sbtBeep = 0; //停止发声，并将sbtBeep端口置于低电平
 496   2              }
 497   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1007    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     95       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
