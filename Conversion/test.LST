C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TEST
OBJECT MODULE PLACED IN test.OBJ
COMPILER INVOKED BY: G:\Keil\C51\BIN\C51.EXE test.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <stdlib.h>
   4          #define uint unsigned int
   5          #define uchar unsigned char
   6          
   7          /*---------宏定义---------*/
   8          #define cstAdcPower 0X80   /*ADC电源开关*/
   9          #define cstAdcFlag 0X10    /*当A/D转换完成后，cstAdcFlag要软件清零*/
  10          #define cstAdcStart 0X08   /*当A/D转换完成后，cstAdcStart会自动清零，所以要开始下一次转换，则需要置位*/
  11          #define cstAdcSpeed90 0X60 /*ADC转换速度 90个时钟周期转换一次*/
  12          #define cstAdcChs17 0X07   /*选择P1.7作为A/D输入*/
  13          
  14          uchar arrSegSelect[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x00, 0x38, 0x74, 0x67, 0xa7};
  15          uchar arrDigitSelect[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; //数码管0-7
  16          uchar arrLEDselect[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};   //LED灯
  17          uint arrPrintSelect[]={16,16,16,16,16,16,16,16};
  18          uchar arrListSelect[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  19          /*---------引脚别名定义---------*/
  20          sbit sbtLedSel = P2 ^ 3; //数码管与LED灯切换引脚
  21          sbit sbtVib = P2 ^ 4;     //振动传感器
  22          
  23          /*---------变量定义---------*/
  24          uchar uiLed = 0x00;      //LED灯值寄存
  25          uchar tmpLed = 0x01; //LED灯值暂存
  26          uchar i = 0;             //数码管扫描显示循环
  27          uint answer = 0;         //答案
  28          uint score = 0;          //得分
  29          uint highest_sc = 0; //最高分
  30          uint highest_er=0;       //最高分玩家
  31          uint player=0;           //当前游戏玩家
  32          uint ques = 0;           //问题
  33          uint ques0, ques1, ques2;
  34          uint ques_flag = 0; //问题标志
  35          uchar option=0x00;              //选项
  36          uint back=0;
  37          
  38          /*---------引脚别名定义---------*/
  39          sbit sbtBeep = P3 ^ 4; //蜂鸣器引脚
  40          sbit sbtKey1 = P3 ^ 2; //按键1引脚
  41          sbit sbtKey2 = P3 ^ 3;
  42          sbit sbtKey3 = P1 ^ 7;
  43          /*---------变量定义---------*/
  44          bit btBeepFlag; //控制蜂鸣器开关的标志位
  45           
  46          
  47          /*---------初始化函数--------*/
  48          void Init()
  49          {
  50   1              P0M1 = 0x00;
  51   1              P0M0 = 0xff;
  52   1              P2M1 = 0x00;
  53   1              P2M0 = 0x08;
  54   1              P3M1 = 0x00;
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 2   

  55   1              P3M0 = 0x10; //设置P3^4为推挽模式
  56   1              
  57   1          sbtLedSel = 0;      //选择数码管作为输出
  58   1          P1ASF = 0x80;       //P1.7作为模拟功能A/D使用
  59   1          ADC_RES = 0;        //转换结果清零
  60   1          ADC_CONTR = 0x8F;   //cstAdcPower = 1
  61   1          CLK_DIV = 0X00;     //ADRJ = 0    ADC_RES存放高八位结果
  62   1          IT0 = 0;            //设置IT0上升沿触发
  63   1          IT1 = 0;
  64   1          EA = 1;             //CPU开放中断
  65   1              TMOD = 0x00; //设置定时器0，工作方式0，16位自动重装定时器
  66   1              TH0 = 0xff;      //设定定时器0的初值
  67   1              TL0 = 0x03;
  68   1              ET0 = 1; //打开定时器0中断允许位
  69   1              TR0 = 1;
  70   1              btBeepFlag = 0; //标志位置1
  71   1              P0 = 0x00;              //关闭P0端口
  72   1              sbtBeep = 0;    //蜂鸣器引脚置0，以保护蜂鸣器
  73   1              ques_flag = 0;
  74   1              sbtLedSel = 0; //先选择数码管亮
  75   1              uiLed = 0x00;
  76   1              sbtVib=1;
  77   1      }
  78          /*---------延时子函数--------*/
  79          void delay(uint n)
  80          {
  81   1              while (n--)
  82   1                      ;
  83   1      }
  84          void delay_ms( uint n )
  85          {
  86   1          while( n )
  87   1          {
  88   2              uchar i, j;
  89   2              i = 11;
  90   2              j = 190;
  91   2              do
  92   2              {
  93   3                  while ( --j );
  94   3              }
  95   2              while ( --i );
  96   2              n--;
  97   2          }
  98   1      }
  99          int game_back();
 100          void upload()
 101          {
 102   1              uiLed = 0x00;
 103   1              tmpLed = 0x01;
 104   1              ques_flag = 0;
 105   1              answer = P0;
 106   1              if (answer == ques)
 107   1              {
 108   2                      score++;
 109   2                      if (score == 15)
 110   2                      {
 111   3                              highest_sc = score;
 112   3                              highest_er = player;
 113   3                              score=0;
 114   3                      }
 115   2              }
 116   1              else
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 3   

 117   1              {
 118   2                      if (score > highest_sc)
 119   2                      {
 120   3                              highest_sc = score;
 121   3                              highest_er = player;
 122   3                      }
 123   2                      /*btBeepFlag = ~btBeepFlag;
 124   2                      delay(600);
 125   2                      btBeepFlag = ~btBeepFlag;*/
 126   2                      score = 0;
 127   2              }
 128   1      }
 129          
 130          /*---------获取AD值子函数--------*/
 131          unsigned char GetADC()
 132          {
 133   1          uchar ucAdcRes;
 134   1          ADC_CONTR = cstAdcPower | cstAdcStart | cstAdcSpeed90 | cstAdcChs17;//没有将cstAdcFlag置1，用于判断A/D
             -是否结束
 135   1          _nop_();
 136   1          _nop_();
 137   1          _nop_();
 138   1          _nop_();
 139   1          while( !( ADC_CONTR & cstAdcFlag ) ); //等待直到A/D转换结束
 140   1          ADC_CONTR &= ~cstAdcFlag;           //cstAdcFlagE软件清0
 141   1          ucAdcRes = ADC_RES;                 //获取AD的值
 142   1          return ucAdcRes;
 143   1      }
 144          
 145          /*---------获取导航按键值子函数--------*/
 146          uchar NavKeyCheck()
 147          {
 148   1              unsigned char key;
 149   1              key = GetADC(); //获取AD的值
 150   1              if (key != 255) //有按键按下时
 151   1              {
 152   2                      delay(200);
 153   2                      key = GetADC();
 154   2                      if (key != 255) //按键消抖 仍有按键按下
 155   2                      {
 156   3                              key = key & 0xE0;         //获取高3位，其他位清零
 157   3                              key = _cror_(key, 5); //循环右移5位 获取A/D转换高三位值，减小误差
 158   3                              return key;
 159   3                      }
 160   2              }
 161   1              return 0x07; //没有按键按下时返回值0x07
 162   1      }
 163          
 164          /*---------导航按键处理子函数--------*/
 165          void NavKey_Process()
 166          {
 167   1              uchar ucNavKeyCurrent; //导航按键当前的状态
 168   1              uchar ucNavKeyPast;        //导航按键前一个状态
 169   1      
 170   1              ucNavKeyCurrent = NavKeyCheck(); //获取当前ADC值
 171   1              if (ucNavKeyCurrent != 0x07)     //导航按键是否被按下 不等于0x07表示有按下
 172   1              {
 173   2                      ucNavKeyPast = ucNavKeyCurrent;
 174   2                      while (ucNavKeyCurrent != 0x07) //等待导航按键松开
 175   2                              ucNavKeyCurrent = NavKeyCheck();
 176   2      
 177   2              switch( ucNavKeyPast )
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 4   

 178   2              {
 179   3                  case 0x00 :                     //里
 180   3                              if (tmpLed == 0x00)
 181   3                                              tmpLed = 0x01;
 182   3                                      else
 183   3                                              tmpLed = tmpLed & 0x00;
 184   3                      break;
 185   3                  case 0x01 :                     //上键：显示的数字加1
 186   3                      if (tmpLed == 0x01) //value等于0x80时，重新赋初值0x01
 187   3                                      tmpLed = 0x80;
 188   3                                      else
 189   3                                      tmpLed = tmpLed >> 1;
 190   3                      break;
 191   3                  case 0x04 :                     //下键：显示的数字减1
 192   3                      if (tmpLed == 0x80) //value等于0x80时，重新赋初值0x01
 193   3                                              tmpLed = 0x01;
 194   3                                      else
 195   3                                              tmpLed = tmpLed << 1;
 196   3                      break;
 197   3                              case 0x02:
 198   3                                      back=game_back();
 199   3                                      break;
 200   3              }
 201   2          }
 202   1      
 203   1          delay(1000);
 204   1      }
 205          
 206          void question()
 207          {
 208   1              ques = rand() % 256;
 209   1              ques0 = ques % 10;
 210   1              ques1 = ques / 10 % 10;
 211   1              ques2 = ques / 100 % 10;
 212   1      }
 213          
 214          void clear()
 215          {
 216   1              for(i=0;i<8;i++)
 217   1                      arrPrintSelect[i]=16;
 218   1      }
 219          
 220          void print()
 221          {
 222   1              for( i = 0; i < 8; i++ )
 223   1              {
 224   2                  P0 = 0;
 225   2                  P2 = arrDigitSelect[i];     //选择数码管的位数
 226   2                  P0 = arrSegSelect[arrPrintSelect[i]];  //显示对应的数值
 227   2                  delay_ms( 1 );
 228   2              }
 229   1      }
 230          
 231          void print_game()
 232          {
 233   1              clear();
 234   1              arrPrintSelect[0]=highest_sc;
 235   1              arrPrintSelect[3]=score;
 236   1              arrPrintSelect[5]=ques2;
 237   1              arrPrintSelect[6]=ques1;
 238   1              arrPrintSelect[7]=ques0;
 239   1      }
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 5   

 240          
 241          void print_manu()
 242          {
 243   1              clear();
 244   1              if(option==0x00)//GO
 245   1              {
 246   2                      arrPrintSelect[0]=0;
 247   2                      arrPrintSelect[4]=9;
 248   2                      arrPrintSelect[5]=0;
 249   2              }
 250   1              else
 251   1              {
 252   2                      arrPrintSelect[0]=1;
 253   2                      arrPrintSelect[4]=17;
 254   2                      arrPrintSelect[5]=1;
 255   2                      arrPrintSelect[6]=5;
 256   2                      arrPrintSelect[7]=7;
 257   2              }
 258   1      }
 259          
 260          void print_list()
 261          {
 262   1              clear();
 263   1              if(option==0x00)//high
 264   1              {
 265   2                      arrPrintSelect[0]=18;
 266   2                      arrPrintSelect[1]=1;
 267   2                      arrPrintSelect[2]=9;
 268   2                      arrPrintSelect[3]=18;
 269   2                      arrPrintSelect[5]=highest_er;
 270   2                      arrPrintSelect[7]=highest_sc;
 271   2              }
 272   1              else
 273   1              {
 274   2                      arrPrintSelect[0]=17;
 275   2                      arrPrintSelect[1]=1;
 276   2                      arrPrintSelect[2]=5;
 277   2                      arrPrintSelect[3]=7;
 278   2                      arrPrintSelect[5]=option-1;
 279   2                      arrPrintSelect[7]=arrListSelect[option-1];
 280   2              }
 281   1      }
 282          
 283          void print_login()
 284          {
 285   1              clear();
 286   1              arrPrintSelect[2]=1;
 287   1              arrPrintSelect[3]=13;
 288   1              arrPrintSelect[7]=player;
 289   1      }
 290          
 291          void print_back()
 292          {
 293   1              clear();
 294   1              arrPrintSelect[6]=19;
 295   1              arrPrintSelect[7]=20;
 296   1      }
 297          
 298          int game_back()
 299          {
 300   1              while( 1 )
 301   1          {
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 6   

 302   2                      sbtLedSel = 0;
 303   2                      print_back();
 304   2                      print();
 305   2              if (sbtKey1 == 0)
 306   2                      {
 307   3                              delay_ms(5); //延时消抖
 308   3                              if (sbtKey1 == 0)
 309   3                              {
 310   4                                      while( !sbtKey1 );
 311   4                                      {
 312   5                                              return 1;
 313   5                                      }
 314   4                              }
 315   3                      }
 316   2                      if (sbtKey2 == 0)
 317   2                      {
 318   3                              delay_ms(5); //延时消抖
 319   3                              if (sbtKey2 == 0)
 320   3                              {
 321   4                                      while( !sbtKey2 );
 322   4                                      {
 323   5                                              return 0;
 324   5                                      }
 325   4                              }
 326   3                      }
 327   2          }
 328   1      }
 329          
 330          void game()
 331          {
 332   1              clear();
 333   1              while( 1 )
 334   1          {
 335   2                      loop1:
 336   2                      sbtLedSel = 0;
 337   2                      if (ques_flag == 0)
 338   2                      {
 339   3                              question();
 340   3                              ques_flag = 1;
 341   3                      }
 342   2                      print_game();
 343   2                      print();
 344   2                      sbtLedSel = 1;
 345   2                      P0 = 0;
 346   2                      P0 = uiLed | tmpLed; //LED显示
 347   2                      delay_ms(1);    
 348   2                      NavKey_Process();         //获取按键按下情况
 349   2              if (sbtKey1 == 0)
 350   2                      {
 351   3                              delay_ms(5); //延时消抖
 352   3                              if (sbtKey1 == 0)
 353   3                              {
 354   4                                      while( !sbtKey1 );
 355   4                                      upload();
 356   4                                      goto loop1;
 357   4                              }
 358   3                      }
 359   2                      if (sbtKey2 == 0)
 360   2                      {
 361   3                              delay_ms(5); //延时消抖
 362   3                              if (sbtKey2 == 0)
 363   3                              {
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 7   

 364   4                                      while( !sbtKey2 );
 365   4                      uiLed = uiLed ^ tmpLed;
 366   4                              }
 367   3                      }
 368   2                      
 369   2                      //后加退出方法
 370   2          }
 371   1      }
 372          
 373          /*---------注册--------*/
 374          void login()
 375          {
 376   1              option=0x00;
 377   1              back=0;
 378   1              while( 1 )
 379   1          {
 380   2                      sbtLedSel = 0;
 381   2                      print_login();
 382   2                      print();
 383   2              if (sbtKey1 == 0)
 384   2                      {
 385   3                              delay_ms(5); //延时消抖
 386   3                              if (sbtKey1 == 0)
 387   3                              {
 388   4                                      while( !sbtKey1 );
 389   4                                      {
 390   5                                              game();
 391   5                                              return;
 392   5                                      }
 393   4                              }
 394   3                      }
 395   2                      if (sbtKey2 == 0)
 396   2                      {
 397   3                              delay_ms(5); //延时消抖
 398   3                              if (sbtKey2 == 0)
 399   3                              {
 400   4                                      while( !sbtKey2 );
 401   4                                      if(player==15)
 402   4                                              player=0;
 403   4                                      else
 404   4                                              player++;
 405   4                      //next
 406   4                              }
 407   3                      }
 408   2          }
 409   1              
 410   1      }
 411          
 412          /*---------排行--------*/
 413          void list()
 414          {
 415   1              option=0x00;
 416   1              while( 1 )
 417   1          {
 418   2                      sbtLedSel = 0;
 419   2                      print_list();
 420   2                      print();
 421   2              if (sbtKey1 == 0)
 422   2                      {
 423   3                              delay_ms(5); //延时消抖
 424   3                              if (sbtKey1 == 0)
 425   3                              {
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 8   

 426   4                                      while( !sbtKey1 );
 427   4                                      {
 428   5                                              option=0x00;
 429   5                                              break;
 430   5                                      }
 431   4                              }
 432   3                      }
 433   2                      if (sbtKey2 == 0)
 434   2                      {
 435   3                              delay_ms(5); //延时消抖
 436   3                              if (sbtKey2 == 0)
 437   3                              {
 438   4                                      while( !sbtKey2 );
 439   4                                      if(option==0x10)
 440   4                                              option=0x00;
 441   4                                      else
 442   4                                              option++;
 443   4                      //next
 444   4                              }
 445   3                      }
 446   2          }
 447   1      }
 448          
 449          /*---------主函数--------*/
 450          void main()
 451          {
 452   1          Init();
 453   1          while( 1 )
 454   1          {
 455   2                      sbtLedSel = 0;
 456   2                      print_manu();
 457   2                      print();
 458   2              if (sbtKey1 == 0)
 459   2                      {
 460   3                              delay_ms(5); //延时消抖
 461   3                              if (sbtKey1 == 0)
 462   3                              {
 463   4                                      while( !sbtKey1 );
 464   4                                      if(option==0x00)
 465   4                                              login();//注册并开始游戏
 466   4                                      else
 467   4                                              list();//查看排行
 468   4                              }
 469   3                      }
 470   2                      if (sbtKey2 == 0)
 471   2                      {
 472   3                              delay_ms(5); //延时消抖
 473   3                              if (sbtKey2 == 0)
 474   3                              {
 475   4                                      while( !sbtKey2 );
 476   4                      option=option^0x01;
 477   4                              }
 478   3                      }
 479   2          }
 480   1      }
 481          
 482          /*---------T0定时器中断服务处理函数--------*/
 483          void T0_Process() interrupt 1
 484          {
 485   1              if (btBeepFlag)
 486   1              {
 487   2                      sbtBeep = ~sbtBeep; //产生方波使得蜂鸣器发声
C51 COMPILER V9.51   TEST                                                                  09/11/2020 17:09:50 PAGE 9   

 488   2              }
 489   1              else
 490   1              {
 491   2                      sbtBeep = 0; //停止发声，并将sbtBeep端口置于低电平
 492   2              }
 493   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    993    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     95       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
