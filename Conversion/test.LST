C51 COMPILER V9.51   TEST                                                                  09/10/2020 17:21:33 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE TEST
OBJECT MODULE PLACED IN test.OBJ
COMPILER INVOKED BY: G:\Keil\C51\BIN\C51.EXE test.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <stdlib.h>
   4          #define uint unsigned int
   5          #define uchar unsigned char
   6          
   7          /*---------宏定义---------*/
   8          #define cstAdcPower 0X80   /*ADC电源开关*/
   9          #define cstAdcFlag 0X10    /*当A/D转换完成后，cstAdcFlag要软件清零*/
  10          #define cstAdcStart 0X08   /*当A/D转换完成后，cstAdcStart会自动清零，所以要开始下一次转换，则需要置位*/
  11          #define cstAdcSpeed90 0X60 /*ADC转换速度 90个时钟周期转换一次*/
  12          #define cstAdcChs17 0X07   /*选择P1.7作为A/D输入*/
  13          
  14          uchar arrSegSelect[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e
             -, 0x79, 0x71, 0x00};
  15          uchar arrDigitSelect[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}; //数码管0-7
  16          uchar arrLEDselect[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};   //LED灯
  17          uint arrPrintSelect[]={16,16,16,16,16,16,16,16};
  18          
  19          /*---------引脚别名定义---------*/
  20          sbit sbtLedSel = P2 ^ 3; //数码管与LED灯切换引脚
  21          
  22          /*---------变量定义---------*/
  23          uchar uiLed = 0x00;      //LED灯值寄存
  24          uchar tmpLed = 0x01; //LED灯值暂存
  25          uchar i = 0;             //数码管扫描显示循环
  26          uint answer = 0;         //答案
  27          uint score = 0;          //得分
  28          uint highest_sc = 0; //最高分
  29          uint ques = 0;           //问题
  30          uint ques0, ques1, ques2;
  31          uint ques_flag = 0; //问题标志
  32          
  33          /*---------引脚别名定义---------*/
  34          sbit sbtBeep = P3 ^ 4; //蜂鸣器引脚
  35          sbit sbtKey1 = P3 ^ 2; //按键1引脚
  36          sbit sbtKey2 = P3 ^ 3;
  37          sbit sbtKey3 = P1 ^ 7;
  38          /*---------变量定义---------*/
  39          bit btBeepFlag; //控制蜂鸣器开关的标志位
  40           
  41          
  42          /*---------初始化函数--------*/
  43          void Init()
  44          {
  45   1              P0M1 = 0x00;
  46   1              P0M0 = 0xff;
  47   1              P2M1 = 0x00;
  48   1              P2M0 = 0x08;
  49   1              P3M1 = 0x00;
  50   1              P3M0 = 0x10; //设置P3^4为推挽模式
  51   1              
  52   1          sbtLedSel = 0;      //选择数码管作为输出
  53   1          P1ASF = 0x80;       //P1.7作为模拟功能A/D使用
  54   1          ADC_RES = 0;        //转换结果清零
C51 COMPILER V9.51   TEST                                                                  09/10/2020 17:21:33 PAGE 2   

  55   1          ADC_CONTR = 0x8F;   //cstAdcPower = 1
  56   1          CLK_DIV = 0X00;     //ADRJ = 0    ADC_RES存放高八位结果
  57   1          IT0 = 0;            //设置IT0上升沿触发
  58   1          IT1 = 0;
  59   1          EA = 1;             //CPU开放中断
  60   1              TMOD = 0x00; //设置定时器0，工作方式0，16位自动重装定时器
  61   1              TH0 = 0xff;      //设定定时器0的初值
  62   1              TL0 = 0x03;
  63   1              ET0 = 1; //打开定时器0中断允许位
  64   1              TR0 = 1;
  65   1              btBeepFlag = 0; //标志位置1
  66   1              P0 = 0x00;              //关闭P0端口
  67   1              sbtBeep = 0;    //蜂鸣器引脚置0，以保护蜂鸣器
  68   1              ques_flag = 0;
  69   1              sbtLedSel = 0; //先选择数码管亮
  70   1              uiLed = 0x00;
  71   1      }
  72          /*---------延时子函数--------*/
  73          void delay(uint n)
  74          {
  75   1              while (n--)
  76   1                      ;
  77   1      }
  78          void delay_ms( uint n )
  79          {
  80   1          while( n )
  81   1          {
  82   2              uchar i, j;
  83   2              i = 11;
  84   2              j = 190;
  85   2              do
  86   2              {
  87   3                  while ( --j );
  88   3              }
  89   2              while ( --i );
  90   2              n--;
  91   2          }
  92   1      }
  93          void upload()
  94          {
  95   1              uiLed = 0x00;
  96   1              tmpLed = 0x01;
  97   1              ques_flag = 0;
  98   1              answer = P0;
  99   1              if (answer == ques)
 100   1              {
 101   2                      score++;
 102   2                      btBeepFlag = ~btBeepFlag;
 103   2                      delay(600);
 104   2                      btBeepFlag = ~btBeepFlag;
 105   2                      if (score == 2)
 106   2                      {
 107   3                              btBeepFlag = ~btBeepFlag;
 108   3                              delay(600);
 109   3                              btBeepFlag = ~btBeepFlag;
 110   3                      }
 111   2              }
 112   1              else
 113   1              {
 114   2                      if (score > highest_sc)
 115   2                              highest_sc = score;
 116   2                      btBeepFlag = ~btBeepFlag;
C51 COMPILER V9.51   TEST                                                                  09/10/2020 17:21:33 PAGE 3   

 117   2                      delay(600);
 118   2                      btBeepFlag = ~btBeepFlag;
 119   2                      score = 0;
 120   2              }
 121   1      }
 122          
 123          /*---------获取AD值子函数--------*/
 124          unsigned char GetADC()
 125          {
 126   1          uchar ucAdcRes;
 127   1          ADC_CONTR = cstAdcPower | cstAdcStart | cstAdcSpeed90 | cstAdcChs17;//没有将cstAdcFlag置1，用于判断A/D
             -是否结束
 128   1          _nop_();
 129   1          _nop_();
 130   1          _nop_();
 131   1          _nop_();
 132   1          while( !( ADC_CONTR & cstAdcFlag ) ); //等待直到A/D转换结束
 133   1          ADC_CONTR &= ~cstAdcFlag;           //cstAdcFlagE软件清0
 134   1          ucAdcRes = ADC_RES;                 //获取AD的值
 135   1          return ucAdcRes;
 136   1      }
 137          
 138          /*---------获取导航按键值子函数--------*/
 139          uchar NavKeyCheck()
 140          {
 141   1              unsigned char key;
 142   1              key = GetADC(); //获取AD的值
 143   1              if (key != 255) //有按键按下时
 144   1              {
 145   2                      delay(200);
 146   2                      key = GetADC();
 147   2                      if (key != 255) //按键消抖 仍有按键按下
 148   2                      {
 149   3                              key = key & 0xE0;         //获取高3位，其他位清零
 150   3                              key = _cror_(key, 5); //循环右移5位 获取A/D转换高三位值，减小误差
 151   3                              return key;
 152   3                      }
 153   2              }
 154   1              return 0x07; //没有按键按下时返回值0x07
 155   1      }
 156          
 157          /*---------导航按键处理子函数--------*/
 158          void NavKey_Process()
 159          {
 160   1              uchar ucNavKeyCurrent; //导航按键当前的状态
 161   1              uchar ucNavKeyPast;        //导航按键前一个状态
 162   1      
 163   1              ucNavKeyCurrent = NavKeyCheck(); //获取当前ADC值
 164   1              if (ucNavKeyCurrent != 0x07)     //导航按键是否被按下 不等于0x07表示有按下
 165   1              {
 166   2                      ucNavKeyPast = ucNavKeyCurrent;
 167   2                      while (ucNavKeyCurrent != 0x07) //等待导航按键松开
 168   2                              ucNavKeyCurrent = NavKeyCheck();
 169   2      
 170   2              switch( ucNavKeyPast )
 171   2              {
 172   3                  case 0x00 :                     //里
 173   3                              if (tmpLed == 0x00)
 174   3                                              tmpLed = 0x01;
 175   3                                      else
 176   3                                              tmpLed = tmpLed & 0x00;
 177   3                      break;
C51 COMPILER V9.51   TEST                                                                  09/10/2020 17:21:33 PAGE 4   

 178   3                  case 0x01 :                     //上键：显示的数字加1
 179   3                      if (tmpLed == 0x01) //value等于0x80时，重新赋初值0x01
 180   3                                      tmpLed = 0x80;
 181   3                                      else
 182   3                                      tmpLed = tmpLed >> 1;
 183   3                      break;
 184   3                  case 0x04 :                     //下键：显示的数字减1
 185   3                      if (tmpLed == 0x80) //value等于0x80时，重新赋初值0x01
 186   3                                              tmpLed = 0x01;
 187   3                                      else
 188   3                                              tmpLed = tmpLed << 1;
 189   3                      break;
 190   3              }
 191   2          }
 192   1      
 193   1          delay(1000);
 194   1      }
 195          
 196          void question()
 197          {
 198   1              ques = rand() % 256;
 199   1              ques0 = ques % 10;
 200   1              ques1 = ques / 10 % 10;
 201   1              ques2 = ques / 100 % 10;
 202   1      }
 203          
 204          void print()
 205          {
 206   1              for( i = 0; i < 8; i++ )
 207   1              {
 208   2                  P0 = 0;
 209   2                  P2 = arrDigitSelect[i];     //选择数码管的位数
 210   2                  P0 = arrSegSelect[arrPrintSelect[i]];  //显示对应的数值
 211   2                  delay_ms( 1 );
 212   2              }
 213   1      }
 214          
 215          void print_game()
 216          {
 217   1              arrPrintSelect[0]=highest_sc;
 218   1              arrPrintSelect[3]=score;
 219   1              arrPrintSelect[5]=ques2;
 220   1              arrPrintSelect[6]=ques1;
 221   1              arrPrintSelect[7]=ques0;
 222   1      }
 223          
 224          /*---------主函数--------*/
 225          void main()
 226          {
 227   1          Init();
 228   1          while( 1 )
 229   1          {
 230   2                      sbtLedSel = 0;
 231   2                      if (ques_flag == 0)
 232   2                      {
 233   3                              question();
 234   3                              ques_flag = 1;
 235   3                      }
 236   2                      print_game();
 237   2                      print();
 238   2                      sbtLedSel = 1;
 239   2                      P0 = 0;
C51 COMPILER V9.51   TEST                                                                  09/10/2020 17:21:33 PAGE 5   

 240   2                      P0 = uiLed | tmpLed; //LED显示
 241   2                      delay_ms(1);    
 242   2                      NavKey_Process();         //获取按键按下情况
 243   2              if (sbtKey1 == 0)
 244   2                      {
 245   3                              delay_ms(5); //延时消抖
 246   3                              if (sbtKey1 == 0)
 247   3                              {
 248   4                                      while( !sbtKey1 );
 249   4                                      upload();
 250   4                              }
 251   3                      }
 252   2                      if (sbtKey2 == 0)
 253   2                      {
 254   3                              delay_ms(5); //延时消抖
 255   3                              if (sbtKey2 == 0)
 256   3                              {
 257   4                                      while( !sbtKey2 );
 258   4                      uiLed = uiLed ^ tmpLed;
 259   4                              }
 260   3                      }
 261   2          }
 262   1      }
 263          
 264          /*---------T0定时器中断服务处理函数--------*/
 265          void T0_Process() interrupt 1
 266          {
 267   1              if (btBeepFlag)
 268   1              {
 269   2                      sbtBeep = ~sbtBeep; //产生方波使得蜂鸣器发声
 270   2              }
 271   1              else
 272   1              {
 273   2                      sbtBeep = 0; //停止发声，并将sbtBeep端口置于低电平
 274   2              }
 275   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    567    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     68       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
